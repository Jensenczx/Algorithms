##求最大公约数
###第一思路
通过比较得到两个数种较小的数字，然后对其进行遍历，记录最大的能够同时被两个数同时整除的数据，即为我们要求的最大公约数，时间复杂度为o(较小数)
###正确思路
通过使用欧几里德算法，将第二个数据默认为除数，然后对除数的取值首先进行一个是否为0的判断，然后通过被除数除以除数取余，得到的数据作为除数，将较小数据作为被除数，再次递归调用该方法，当除数为0的时候，返回被除数。
###实现原理

递归实现的算法，我们常会遵循以下三点

1. 递归总会存在一个最简单的情况，需要我们去寻找这个特殊情况
 2. 递归总是尝试去解决更小规模的问题
 3. 父问题和子问题之间不应该存在交集
 
 首先是对除数进行判断，当除数为0的时候，是不符合编程规范的，同时也说明这两个数的最大公约数是第一个数，然后当其不为零的时候，我们通过两个数相除来获取其余数，这个余数的值也就是决定前一个数是否能够被另一个数整除，如果能够整除，那么这两个数的最大公约数就是除数，如果不能整除，那么我们需要求得就是除数和余数之间的最大相同子因式，也就是去解决一个更小规模的子问题，而且这个子问题和父问题是不存在交集的。以此递归下去，当余数为0的时候，我们就可以得到这两个因式的最大公约数。
 
 ```
 public int gcd(int p,int q){
		if(q==0) return p;
		int r=p%q;
		return gcd(q,r);
	}
 ```